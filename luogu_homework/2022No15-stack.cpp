
#include <queue>
#include<stack>
#include <iostream>
using namespace std;
/*
# 栈STL练习
## 题目描述
给定一个正整数数列（以$0$表示输入结束），从第一个数开始，将每一个数入**栈**，**入栈的同时**获得一个分数，即该数的数值乘以入栈后栈的大小 （即**插入后**栈的 $size$ ，请计算将所有元素入栈后的分数和，然后将栈内元素依次输出。
## 输入格式
共一行，一个正整数数列，以$0$结尾。
## 输出格式
共两行，第一行为一个正整数，表示分数和。
第二行为将所有元素出栈后的结果，空格分隔。
## 样例 #1
### 样例输入 #1
```
1 1 1 1 0
```
### 样例输出 #1
```
10
1 1 1 1
```
## 提示
所有输入输出均小于 $10^3$*/
// #include<stack>
// #include <iostream>
// using namespace std;
int stl_stack(){
	int n,cnt=0;
	stack<int> s;
	cin>>n;
	while(n!=0){
		s.push(n);
		cnt+=s.size()*n;
		cin>>n;
	}
	cout<<cnt<<endl;
	while(!s.empty()){
		cout<<s.top()<<" ";
		s.pop();
	}
	return 0;
}
/*
# 孤独的左括号
## 题目描述
给出一个合法的，只有左右小括号组成的字符串。当我们从左往右看这个字符串的每一个字符的时候，每当我们看到一个左括号，那么这个左括号左边，还没有匹配成功的左括号的个数，就叫当前这个左括号的孤独值。
举个例子：
`(()())`
当我们看到第一个左括号的时候，它左边没有左括号，所以孤独值为0.
当我们看到第二个左括号的时候，它左边有一个未匹配的左括号，所以第二个左括号的孤独值是1.
接着来了个右括号，那么第二个左括号匹配成功。
第三个左括号来了，此时它左侧虽然有两个左括号，但是只有第一个是未匹配的，第二个是已经被匹配掉了的，所以第三个左括号的孤独值是1.
接着来了右括号，第三个左括号被匹配了。
接着又来了右括号，第一个左括号也被匹配了。此时字符串也结束了，没有多余的左括号，整个串是合法的。
那么所有左括号的孤独值的和是$0+1+1=2$
现在输入一个合法的字符串s，请你计算每个左括号的孤独值并输出它们的孤独值的和
## 输入格式
一行，一个字符串，仅由左右小括号组成。
## 输出格式
一个整数，表示每个左括号的孤独值的和
## 样例 #1
### 样例输入 #1
```
(()())
```
### 样例输出 #1
```
2
```
## 提示
输入的字符串长度不超过$2*10^7$*/

int alone_kuohao() {
	
    return 0;
}
/*
# 字符消消乐
## 题目描述
梁老师家的狗豆豆，特别喜欢玩消消乐的游戏。不过现在手机里面的游戏它已经玩腻了，所以它自己写了一个消消乐来玩。
这个游戏的规则是这样的，输入一个只含有英文字符的字符串s，如果这个字符串中有连续相邻的两个字符，正好是同一个字符，只不过一个是大写，一个是小写，那么这两个字符就要一起消失。当它们消失掉以后，字符串里面它俩原来左右两边的子串就会接在一起，这样也许会产生新的要消掉的部分。
举个例子，输入的字符串是caBbA，那么首先，Bb是相同的字母，并且正好一个大写，一个小写，那么它们俩先消失，字符串变成caA，这时候，aA也满足条件，所以也消失。所以最后只剩下一个c
## 输入格式
输入一行，一个字符串s
## 输出格式
输出所有符合要求的字符都消完以后的字符串
## 样例 #1
### 样例输入 #1
```
caBbA
```
### 样例输出 #1
```
c
```
## 样例 #2
### 样例输入 #2
```
aA
```
### 样例输出 #2
```
```
## 样例 #3
### 样例输入 #3
```
s
```
### 样例输出 #3
```
s
```
## 提示
输入的字符串仅由大小写字母组成，长度不超过$10^7$
*/

// #include<stack>
// #include<iostream>
// using namespace std;
int xiao_xiao_le(){
	char n;
	int a=0;
	string xiao;
	cin>>xiao;
	stack<char> s;
	while(a<int(xiao.size())){
		n=xiao[a];
		if(!s.empty()){
			if(int(n)+32==int(s.top()) || int(n)-32==int(s.top())){
				s.pop();
			}
			else{
				s.push(n);
			}
		}
		else{
			s.push(n);	
		}
		a++;
	}
	while(!s.empty()){
		cout<<s.top();
		s.pop();
	}
	return 0;
}
/*
# 表达式括号匹配(3种类型括号)
## 题目描述
假设一个表达式由英文字母（大小写）数字$0$到$9$、运算符（+，-，*，/）和左右小括号()，左右中括号[]和左右大括号{}构成，以“@”作为表达式的结束符。请编写一个程序检查表达式中的左右括号是否匹配，若匹配，则输出“YES”；否则输出“NO”。表达式长度小于$10^7$。
## 输入格式
一行：表达式
## 输出格式
一行：“YES” 或“NO”
## 样例 #1
### 样例输入 #1
```
fs{f}fsd[(f457jkl)fsdaf]@
```
### 样例输出 #1
```
YES
```
## 样例 #2
### 样例输入 #2
```
fs{{f}fsd[(fsadfjkl)fsdaf]@
```
### 样例输出 #2
```
NO
```
## 样例 #3
### 样例输入 #3
```
)@
```
### 样例输出 #3
```
NO
```
## 样例 #4
### 样例输入 #4
```
([)]@
```
### 样例输出 #4
```
NO
```*/

// #include<stack>
// #include<iostream>
// using namespace std;
int match_brace(){
	char n;
	stack<char> s;
	cin>>n;
	while(n!='@'){
		if(!s.empty()){
			if((n==')' && s.top()=='(') || int(n)-2==int(s.top())){
				s.pop();
			}
			else if(n=='('||n==')'||n==']'||n=='['||n=='{'||n=='}'){
				s.push(n);
			}
		}
		else if(n=='('||n==')'||n==']'||n=='['||n=='{'||n=='}'){
			s.push(n);
		}cin>>n;
	}
	if(s.empty()){
		cout<<"YES";
	}
	else{
		cout<<"NO";
	}
	return 0;
}
/*
# 队列STL练习-卡片游戏
## 题目描述
桌上有一叠牌，从第一张牌（即位于**顶面**的牌）开始从上往下依次编号为$1-n$，当至少还剩两张牌时进行以下操作：把第一张牌扔掉，然后把新的第一张放到整叠牌的最后，输入$n$，输出每次扔掉的牌，以及最后剩下的牌。
## 输入格式
共一行，一个正整数 $n$
## 输出格式
每次扔掉的牌的编码，以及最后扔掉的牌的编码。
每个编码用一个**空格**隔开。
## 样例 #1
### 样例输入 #1
```
7
```
### 样例输出 #1
```
1 3 5 7 4 2 6
```
## 提示
输入输出均小于 $10^6$*/
// #include <iostream>
// #include <queue>
// using namespace std;
int card_game(){
	int a,t;
	cin>>a;
	queue<int>q;
	for(int i=1;i<=a;i++){
		q.push(i);
	}
	while(q.size()>2){
		cout<<q.front()<<" ";
		q.pop();
		t=q.front();
		q.pop();
		q.push(t);
	}
	cout<<q.front()<<" ";
	q.pop();
	cout<<q.front();
	return 0;
}
/*
# 约瑟夫问题
## 题目描述
$n$ 个人围成一圈，从第一个人开始报数,数到 $m$ 的人出列，再由下一个人重新从 $1$ 开始报数，数到 $m$ 的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号。
**注意：本题和《深入浅出-基础篇》上例题的表述稍有不同。书上表述是给出淘汰 $n-1$ 名小朋友，而该题是全部出圈。**
## 输入格式
输入两个整数 $n,m$。
## 输出格式
输出一行 $n$ 个整数，按顺序输出每个出圈人的编号。
## 样例 #1
### 样例输入 #1
```
10 3
```
### 样例输出 #1
```
3 6 9 2 7 1 8 5 10 4
```
## 提示
1≤m,n≤100
*/
// #include <iostream>
// using namespace std;
int Jotheph_problem(){
	int q[102]={true};
    int a,w,i=1,cnt,j=2;
	cin>>a;
	cin>>w;
	for(int i=1;i<=a;i++){
		q[i]=i;
	}
	while(cnt<a){
		if(q[j]==true)i++;
		if(i==w){
			q[j]=false;
			cout<<j<<" ";
			cnt++;
			i=0;
		}
		j++;
		if(j>a){
			j=j%a;
		}
		
	}
	return 0;
}

/*
# 约瑟夫
## 题目描述
$n$ 个人站成一圈，从某个人开始数数，每次数到 $m$ 的人就被杀掉，然后下一个人重新开始数，直到最后只剩一个人。现在有一圈人，$k$ 个好人站在一起，$k$ 个坏人站在一起。从第一个好人开始数数。你要确定一个最小的 $m$，使得在第一个好人被杀死前，$k$ 个坏人先被杀死。
## 输入格式
一行一个整数 $k$。
## 输出格式
一行一个整数 $m$。
## 样例 #1
### 样例输入 #1
```
3
```
### 样例输出 #1
```
5
```
## 样例 #2
### 样例输入 #2
```
4
```
### 样例输出 #2
```
30
```
## 提示
$0\lt k\lt 14$。*/
// #include <iostream>
// using namespace std;
int Jotheph(){
	int a,w,i=1,cnt,j=1;
	cin>>a;
	w=a;
	bool q[a*2+2];
	while(true){
		for(int x=0;x<a*2+2;x++){
		q[x]=true;
		}
		cnt=0;
		i=1;
		j=1;
		while(cnt<a){
			if(q[j]==true)i++;
			j++;
			if(i==w){
				if(j<=a){
					break;
				}
				q[j]=false;
				cnt++;
				i=1;
				if(cnt==a){
					cout<<w;
					return 0;
				}
			}
			
			if(j>=a*2){
				j=j%a*2;
			}	
		}
		w+=1;
	}
	
	return 0;
}
/*
# 后缀表达式求值简单版
## 题目描述
后缀表达式是一种把运算符后置的算术表达式，例如普通的表达式 2 + 3 的后缀表达法为 2 3 +。后缀表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) * 4的后缀表达式为 2 3 + 4 *。
任何一个后缀表达式，计算的方式是唯一确定的，不会出现歧义，所以特别适合用计算机计算。
本题输入一个后缀表达式，请计算它的值，其中运算符包括+ - * /四个。这里的/代表除法，是整除运算，结果只保留商，不保留余数。
## 输入格式
一个后缀表达式（长度不超过100）。其中符号中仅包含“0123456789+-*”/。并且，表达式中的数字都是一位的，不会出现形如12的数字。
## 输出格式
一个整数，代表后缀表达式的值
## 样例 #1
### 样例输入 #1
```
52/2+
```
### 样例输出 #1
```
4
```
## 样例 #2
### 样例输入 #2
```
12+
```
### 样例输出 #2
```
3
```*/
int eva_ext_expression(){
	
    return 0;
}
/*
# 后缀表达式
## 题目描述
所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。
如：$\texttt{3*(5-2)+7}$ 对应的后缀表达式为：$\texttt{3.5.2.-*7.+@}$。在该式中，`@` 为表达式的结束符号。`.` 为操作数的结束符号。
## 输入格式
输入一行一个字符串 $s$，表示后缀表达式。
## 输出格式
输出一个整数，表示表达式的值。
## 样例 #1
### 样例输入 #1
```
3.5.2.-*7.+@
```
### 样例输出 #1
```
16
```
## 提示
数据保证，$1 \leq |s| \leq 50$，答案和计算过程中的每一个值的绝对值不超过 $10^9$。*/
int eva_mid_expression(){
	    return 0;
}

int main(){
	
    stl_stack();
    alone_kuohao(); //no implementation
    xiao_xiao_le(); //0 score
    match_brace();
    Jotheph_problem();
    Jotheph();//0 score
    eva_ext_expression();//no implementation
    eva_mid_expression();//no implementation
    return 0;
	}